package webrtc_signaling

import (
	"encoding/json"
	"log"
	"time"
	// "sync" // Your Signaler used a sync.Mutex, Room uses channels for synchronization
)

// Room manages the set of active clients and broadcasts messages to the clients in a specific room.
type Room struct {
	ID         string
	hub        *Hub
	clients    map[*Client]bool
	broadcast  chan *WebSocketMessage // Channel for messages to be broadcast to all clients in this room
	register   chan *Client
	unregister chan *Client
}

func newRoom(id string, hub *Hub) *Room {
	return &Room{
		ID:         id,
		hub:        hub,
		clients:    make(map[*Client]bool),
		broadcast:  make(chan *WebSocketMessage, 256), // Buffered
		register:   make(chan *Client),
		unregister: make(chan *Client),
	}
}

func (r *Room) run() {
	log.Printf("Room %s started", r.ID)
	defer func() {
		log.Printf("Room %s stopped", r.ID)
		// Optionally notify hub to remove this room if it's managed dynamically
		// r.hub.unregisterRoom <- r.ID
	}()

	for {
		select {
		case client := <-r.register:
			// Similar to your Signaler.AddUserToRoom, but with *Client objects
			if _, exists := r.clients[client]; !exists {
				r.clients[client] = true
				client.room = r // Assign room to client
				log.Printf("Client %s registered to room %s. Total clients: %d", client.UserID, r.ID, len(r.clients))

				// Notify others in the room that a new user joined
				joinMsgPayload := SystemMessagePayload{
					Event:   "user_joined_room",
					Message: client.UserID + " joined the room.",
				}
				joinMsg := &WebSocketMessage{
					Type:         "system_event",
					Payload:      joinMsgPayload,
					RoomID:       r.ID,
					SenderUserID: "system", // Or client.UserID if preferred
					Timestamp:    time.Now().UnixMilli(),
				}
				r.broadcastToRoom(joinMsg, client) // Broadcast to others
			} else {
				log.Printf("Client %s already in room %s.", client.UserID, r.ID)
			}

		case client := <-r.unregister:
			if _, ok := r.clients[client]; ok {
				delete(r.clients, client)
				close(client.send) // Important: Close the client's send channel
				log.Printf("Client %s unregistered from room %s. Remaining clients: %d", client.UserID, r.ID, len(r.clients))

				// Notify others
				leaveMsgPayload := SystemMessagePayload{
					Event:   "user_left_room",
					Message: client.UserID + " left the room.",
				}
				leaveMsg := &WebSocketMessage{
					Type:         "system_event",
					Payload:      leaveMsgPayload,
					RoomID:       r.ID,
					SenderUserID: "system",
					Timestamp:    time.Now().UnixMilli(),
				}
				r.broadcastToRoom(leaveMsg, nil) // Broadcast to all remaining

				if len(r.clients) == 0 {
					log.Printf("Room %s is now empty.", r.ID)
					// Hub can decide to clean up empty rooms
					r.hub.emptyRooms <- r.ID
					return // Stop the room's goroutine
				}
			}

		case message := <-r.broadcast:
			// This message comes from a client's readPump (already enriched)
			// or is a system message generated by the room/hub.
			r.broadcastToRoom(message, nil) // Broadcast to all, nil means no exclusion
		}
	}
}

// broadcastToRoom sends a message to all clients in the room, optionally excluding one.
func (r *Room) broadcastToRoom(message *WebSocketMessage, exclude *Client) {
	messageBytes, err := json.Marshal(message)
	if err != nil {
		log.Printf("Room %s: Error marshalling broadcast message: %v", r.ID, err)
		return
	}

	for client := range r.clients {
		if exclude != nil && client == exclude {
			continue
		}
		select {
		case client.send <- messageBytes:
		default:
			// If send buffer is full, client might be slow or disconnected.
			// Unregister them to prevent blocking.
			log.Printf("Room %s: Client %s send channel full. Closing and unregistering.", r.ID, client.UserID)
			close(client.send)
			delete(r.clients, client) // Directly remove, or send to unregister channel if preferred
			// Could also send a "user_left" message here if unregistering directly
		}
	}
}
